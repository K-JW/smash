/**
\page debug Debugging

Choosing a build type
---------------------

There are different build types available, which compile the SMASH code for
different situations.

For a debug build (with all warnings, but no optimization) use:

      cmake .. -DCMAKE_BUILD_TYPE=Debug

For a release build (full optimization and no warnings) use:

      cmake .. -DCMAKE_BUILD_TYPE=Release

For a profiling build use:

      cmake .. -DCMAKE_BUILD_TYPE=Profiling

The default build type is 'RelWithDebInfo', which provides both optimization
and debug info.

Enhancing build verbosity
-------------------------

To find cmake build errors (best debugged with full compiler output) use:

      make VERBOSE=1

Runtime memory checking with valgrind
-------------------------------------

The SMASH binary is regularly checked by:

      valgrind -v ./smash

Static code analysis & coding style
-----------------------------------

The SMASH source code can be checked via:

      cpplint.py *cc include/ *h
      cppcheck --enable=all -I include/ .

\section debug_profiling Profiling / Benchmarking

\subsection profiling_gprof GPROF

You can tell cmake to create a build for profiling with the \c Profiling build
type:

    cmake -DCMAKE_BUILD_TYPE=Profiling ..

This will compile the smash code like \c Release mode, but with the \c -pg flag
to instrument the code and create a \c gmon.out file whenever you run a binary.
You can look at the \c gmon.out information with gprof.

    # first run smash to create the gmon.out file
    ./smash
    # now run gprof to see the profile information
    gprof smash|less

\subsection profiling_perf Perf

*/
