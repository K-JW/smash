/*
 *
 *    Copyright (c) 2013-2017
 *      SMASH Team
 *
 *    GNU General Public License (GPLv3 or later)
 *
 */

#include "include/crosssections.h"

#include "include/constants.h"
#include "include/kinematics.h"
#include "include/parametrizations.h"
#include "include/particletype.h"

// #include <cmath>

// #include "include/average.h"



namespace smash {

cross_sections::cross_sections(const ParticleList &scat_particles,
                               const double sqrt_s)
    : scattering_particles_(scat_particles),
      sqrt_s_(sqrt_s) {}



// CollisionBranchList cross_sections::call_correct_xs(
//     const ParticleData &data_a, const ParticleData &data_b) const {
//   const auto &pdg_a = scattering_particles_[0].pdgcode();
//   const auto &pdg_b = scattering_particles_[1].pdgcode();
//   CollisionBranchList colls;
//   const bool is_pythia = decide_string();
//
//   // elastic process
//   /** Elastic collisions between two nucleons with sqrt_s() below
//    * low_snn_cut can not happen*/
//   const bool reject_by_nucleon_elastic_cutoff =
//       both_are_nucleons && t1.antiparticle_sign() == t2.antiparticle_sign() &&
//       sqrt_s() < low_snn_cut;
//   if (two_to_two && !reject_by_nucleon_elastic_cutoff) {
//     colls.emplace_back(std::move(elastic(elastic_parameter)));
//   }
//
//   // high energy
//   if (is_pythia) {
//     /* string excitation */
//     colls.emplace_back(std::move(high_energy()));
//   } else { // low energy
//     if (two_to_one) {
//       /* resonance formation (2->1) */
//       colls.emplace_back(std::move(two_to_one()));
//     }
//     if (two_to_two) {
//       /* 2->2 (inelastic) */
//       colls.emplace_back(std::move(two_to_two()));
//     }
//   }
//   return colls;
// }

// bool decide_string() {
//     /* The string fragmentation is implemented in the same way in GiBUU (Physics
//      * Reports 512(2012), 1-124, pg. 33). If the center of mass energy is low, two
//      * particles scatter through the resonance channels. If high, the out going
//      * particles are generated by string fragmentation. If in between, the out
//      * going
//      * particles are generated either through the resonance channels or string
//      * fragmentation by chance. In detail, the low energy regoin is from the
//      * threshold to (mix_scatter_type_energy - mix_scatter_type_window_width),
//      * while
//      * the high energy region is from (mix_scatter_type_energy +
//      * mix_scatter_type_window_width) to infinity. In between, the probability for
//      * string fragmentation increases linearly from 0 to 1 as the c.m. energy.*/
//     // Determine the energy region of the mixed scattering type for two types of
//     // scattering.
//     const ParticleType &t1 = scattering_particles_[0].type();
//     const ParticleType &t2 = scattering_particles_[1].type();
//     const bool both_are_nucleons = t1.is_nucleon() && t2.is_nucleon();
//     bool include_pythia = false;
//     double mix_scatter_type_energy;
//     double mix_scatter_type_window_width;
//     if (both_are_nucleons) {
//       // The energy region of the mixed scattering type for nucleon-nucleon
//       // collision is 4.0 - 5.0 GeV.
//       mix_scatter_type_energy = 4.5;
//       mix_scatter_type_window_width = 0.5;
//       // nucleon-nucleon collisions are included in pythia.
//       include_pythia = true;
//     } else if ((t1.pdgcode().is_pion() && t2.is_nucleon()) ||
//                (t1.is_nucleon() && t2.pdgcode().is_pion())) {
//       // The energy region of the mixed scattering type for pion-nucleon collision
//       // is 2.3 - 3.1 GeV.
//       mix_scatter_type_energy = 2.7;
//       mix_scatter_type_window_width = 0.4;
//       // pion-nucleon collisions are included in pythia.
//       include_pythia = true;
//     }
//     // string fragmentation is enabled when strings_switch is on and the process
//     // is included in pythia.
//     const bool enable_pythia = strings_switch && include_pythia;
//     // Whether the scattering is through string fragmentaion
//     bool is_pythia = false;
//     if (enable_pythia) {
//       if (sqrt_s() > mix_scatter_type_energy + mix_scatter_type_window_width) {
//         // scatterings at high energies are through string fragmentation
//         is_pythia = true;
//       } else if (sqrt_s() >
//                  mix_scatter_type_energy - mix_scatter_type_window_width) {
//         const double probability_pythia =
//             (sqrt_s() - mix_scatter_type_energy + mix_scatter_type_window_width) /
//             mix_scatter_type_window_width / 2.0;
//         if (probability_pythia > Random::uniform(0., 1.)) {
//           // scatterings at the middle energies are through string
//           // fragmentation by chance.
//           is_pythia = true;
//         }
//       }
//     }
//   return is_pythia
// }

// CollisionBranchList cross_sections::two_to_two() {
//   CollisionBranchList process_list;
//   if (data_a.is_baryon() && data_b.is_baryon()) {
//     if (pdg_a.is_nucleon() && pdg_b.is_nucleon() &&
//         pdg_a.antiparticle_sign() == pdg_b.antiparticle_sign()) {
//       // Nucleon Nucleon Scattering
//       process_list =  nn_xx();
//     } else {
//       // Baryon Baryon Scattering
//       process_list =  bb_xx();
//       if (data_a.is_nucleon() && data_b.pdgcode() == data_a.get_antiparticle()->pdgcode()) {
//         // Nucleon Anti-Nucleon Scattering
//         process_list.emplace_back(std::move(NNbar_annihilation());
//       }
//     }
//   } else if (data_a.is_baryon() || data_b.is_baryon()) {
//     // Baryon Meson Scattering
//     if ((pdg_a.is_nucleon() && pdg_b.is_kaon()) ||
//                (pdg_b.is_nucleon() && pdg_a.is_kaon())) {
//       // Nucleon Kaon Scattering
//       process_list =  nk_xx();
//     } else if ((pdg_a.is_hyperon() && pdg_b.is_pion()) ||
//                (pdg_b.is_hyperon() && pdg_a.is_pion())) {
//       // Hyperon Pion Scattering
//       process_list =  ypi_xx();
//     } else if ((pdg_a.is_Delta() && pdg_b.is_kaon()) ||
//                (pdg_b.is_Delta() && pdg_a.is_kaon())) {
//       // Delta Kaon Scattering
//       process_list =  deltak_xx();
//     }
//   } else {
//     // Meson Meson Scattering
//     if ((data_a.pdgcode() == pdg::rho_z && data_b.pdgcode() == pdg::h1) ||
//         (data_a.pdgcode() == pdg::h1 && data_b.pdgcode() == pdg::rho_z)) {
//       // Rho h1 Scattering
//       process_list =  NNbar_creation();
//     }
//   }
// }



CollisionBranchPtr cross_sections::elastic(double elast_par) {
  double elastic_xs = 0.;
  if (elast_par >= 0.) {
    // use constant elastic cross section from config file
    elastic_xs = elast_par;
  } else {
    // use parametrization
    const auto &pdg_a = scattering_particles_[0].pdgcode();
    const auto &pdg_b = scattering_particles_[1].pdgcode();
    if ((pdg_a.is_nucleon() && pdg_b.is_pion()) ||
               (pdg_b.is_nucleon() && pdg_a.is_pion())) {
      // Elastic Nucleon Pion Scattering
      elastic_xs = npi_el();
    } else if ((pdg_a.is_nucleon() && pdg_b.is_kaon()) ||
             (pdg_b.is_nucleon() && pdg_a.is_kaon())) {
      // Elastic Nucleon Kaon Scattering
      elastic_xs = nk_el();
    } else if (pdg_a.is_nucleon() && pdg_b.is_nucleon() &&
               pdg_a.antiparticle_sign() == pdg_b.antiparticle_sign()) {
      // Elastic Nucleon Nucleon Scattering
      elastic_xs = nn_el();
    }
  }
  return make_unique<CollisionBranch>(scattering_particles_[0].type(),
                                      scattering_particles_[1].type(),
                                      elastic_xs,
                                      ProcessType::Elastic);
}

// CollisionBranchPtr cross_sections::high_energy() {
//   CollisionBranchList process_list;
//   if (scattering_particles_[0].is_baryon() &&
//       scattering_particles_[1].is_baryon()) {
//     // High Energy Baryon Baryon Scattering
//     process_list = bb_he();
//   } else if (scattering_particles_[0].is_baryon() ||
//              scattering_particles_[1].is_baryon()) {
//     // High Energy Baryon Meson Scattering
//     process_list = bm_he();
//   }
//   return process_list;
// }



// CollisionBranchList cross_sections::bb_xx() {
//   CollisionBranchList process_list;
//   const ParticleType &type_a = scattering_particles_[0].type();
//   const ParticleType &type_b = scattering_particles_[1].type();
//
//   if (type_a.is_nucleon() || type_a.is_Delta() || type_b.is_nucleon() ||
//       type_b.is_Delta()) {
//     if (type_a.antiparticle_sign() == 1 && type_b.antiparticle_sign() == 1) {
//       /* N R → N N, Δ R → N N */
//       process_list = bar_bar_to_nuc_nuc(false);
//     } else if (type_a.antiparticle_sign() == -1 &&
//                type_b.antiparticle_sign() == -1) {
//       /* N̅ R → N̅ N̅, Δ̅ R → N̅ N̅ */
//       process_list = bar_bar_to_nuc_nuc(true);
//     }
//   }
//   return process_list;
// }


double cross_sections::nn_el() {
  const PdgCode &pdg_a = scattering_particles_[0].type().pdgcode();
  const PdgCode &pdg_b = scattering_particles_[1].type().pdgcode();

  const double s = sqrt_s_ * sqrt_s_;

  /* Use parametrized cross sections. */
  double sig_el;
  if (pdg_a == pdg_b) { /* pp */
    sig_el = pp_elastic(s);
  } else if (pdg_a.is_antiparticle_of(pdg_b)) { /* ppbar */
    sig_el = ppbar_elastic(s);
  } else { /* np */
    sig_el = np_elastic(s);
  }
  if (sig_el > 0.) {
    return sig_el;
  } else {
    std::stringstream ss;
    const auto name_a = scattering_particles_[0].type().name();
    const auto name_b = scattering_particles_[1].type().name();
    ss << "problem in CrossSections::elastic: a=" << name_a << " b=" << name_b
       << " j_a=" << pdg_a.spin() << " j_b=" << pdg_b.spin()
       << " sigma=" << sig_el << " s=" << s;
    throw std::runtime_error(ss.str());
  }
}

double cross_sections::npi_el() {
  const PdgCode &pdg_a = scattering_particles_[0].type().pdgcode();
  const PdgCode &pdg_b = scattering_particles_[1].type().pdgcode();

  const PdgCode &nucleon = pdg_a.is_nucleon() ? pdg_a : pdg_b;
  const PdgCode &pion = pdg_a.is_nucleon() ? pdg_b : pdg_a;
  assert(pion != nucleon);

  const double s = sqrt_s_ * sqrt_s_;

  double sig_el = 0.;
  switch (nucleon.code()) {
    case pdg::p:
      switch (pion.code()) {
        case pdg::pi_p:
          sig_el = piplusp_elastic(s);
          break;
        case pdg::pi_m:
          sig_el = piminusp_elastic(s);
          break;
        case pdg::pi_z:
          sig_el = 0.5 * (piplusp_elastic(s) + piminusp_elastic(s));
          break;
      }
      break;
    case pdg::n:
      switch (pion.code()) {
        case pdg::pi_p:
          sig_el = piminusp_elastic(s);
          break;
        case pdg::pi_m:
          sig_el = piplusp_elastic(s);
          break;
        case pdg::pi_z:
          sig_el = 0.5 * (piplusp_elastic(s) + piminusp_elastic(s));
          break;
      }
      break;
    case -pdg::p:
      switch (pion.code()) {
        case pdg::pi_p:
          sig_el = piminusp_elastic(s);
          break;
        case pdg::pi_m:
          sig_el = piplusp_elastic(s);
          break;
        case pdg::pi_z:
          sig_el = 0.5 * (piplusp_elastic(s) + piminusp_elastic(s));
          break;
      }
      break;
    case -pdg::n:
      switch (pion.code()) {
        case pdg::pi_p:
          sig_el = piplusp_elastic(s);
          break;
        case pdg::pi_m:
          sig_el = piminusp_elastic(s);
          break;
        case pdg::pi_z:
          sig_el = 0.5 * (piplusp_elastic(s) + piminusp_elastic(s));
          break;
      }
      break;
    default:
      throw std::runtime_error(
          "only the elastic cross section for proton-pion "
          "is implemented");
  }

  if (sig_el > 0) {
    return sig_el;
  } else {
    std::stringstream ss;
    const auto name_a = scattering_particles_[0].type().name();
    const auto name_b = scattering_particles_[1].type().name();
    ss << "problem in CrossSections::elastic: a=" << name_a << " b=" << name_b
       << " j_a=" << pdg_a.spin() << " j_b=" << pdg_b.spin()
       << " sigma=" << sig_el << " s=" << s;
    throw std::runtime_error(ss.str());
  }
}

double cross_sections::nk_el() {
  const PdgCode& pdg_a = scattering_particles_[0].type().pdgcode();
  const PdgCode& pdg_b = scattering_particles_[1].type().pdgcode();

  const PdgCode& nucleon = pdg_a.is_nucleon() ? pdg_a : pdg_b;
  const PdgCode& kaon = pdg_a.is_nucleon() ? pdg_b : pdg_a;
  assert(kaon != nucleon);

  const double s = sqrt_s_ * sqrt_s_;

  double sig_el = 0.;
  switch (nucleon.code()) {
    case pdg::p:
      switch (kaon.code()) {
        case pdg::K_p:
          sig_el = kplusp_elastic_background(s);
          break;
        case pdg::K_m:
          sig_el = kminusp_elastic_background(s);
          break;
        case pdg::K_z:
          sig_el = k0p_elastic_background(s);
          break;
        case pdg::Kbar_z:
          sig_el = kbar0p_elastic_background(s);
          break;
      }
      break;
    case pdg::n:
      switch (kaon.code()) {
        case pdg::K_p:
          sig_el = kplusn_elastic_background(s);
          break;
        case pdg::K_m:
          sig_el = kminusn_elastic_background(s);
          break;
        case pdg::K_z:
          sig_el = k0n_elastic_background(s);
          break;
        case pdg::Kbar_z:
          sig_el = kbar0n_elastic_background(s);
          break;
      }
      break;
    case -pdg::p:
      switch (kaon.code()) {
        case pdg::K_p:
          sig_el = kminusp_elastic_background(s);
          break;
        case pdg::K_m:
          sig_el = kplusp_elastic_background(s);
          break;
        case pdg::K_z:
          sig_el = kbar0p_elastic_background(s);
          break;
        case pdg::Kbar_z:
          sig_el = k0p_elastic_background(s);
          break;
      }
      break;
    case -pdg::n:
      switch (kaon.code()) {
        case pdg::K_p:
          sig_el = kminusn_elastic_background(s);
          break;
        case pdg::K_m:
          sig_el = kplusn_elastic_background(s);
          break;
        case pdg::K_z:
          sig_el = kbar0n_elastic_background(s);
          break;
        case pdg::Kbar_z:
          sig_el = k0n_elastic_background(s);
          break;
      }
      break;
    default:
      throw std::runtime_error(
          "elastic cross section for antinucleon-kaon "
          "not implemented");
  }

  if (sig_el > 0) {
    return sig_el;
  } else {
    std::stringstream ss;
    const auto name_a = scattering_particles_[0].type().name();
    const auto name_b = scattering_particles_[1].type().name();
    ss << "problem in CrossSections::elastic: a=" << name_a << " b=" << name_b
       << " j_a=" << pdg_a.spin() << " j_b=" << pdg_b.spin()
       << " sigma=" << sig_el << " s=" << s;
    throw std::runtime_error(ss.str());
  }
}

CollisionBranchList cross_sections::two_to_one() {
  // const auto &log = logger<LogArea::ScatterAction>();
  CollisionBranchList resonance_process_list;
  /* There is no resonance formation out of two baryons: Return empty list. */
  if (!(scattering_particles_[0].is_baryon() &&
        scattering_particles_[1].is_baryon())) {
    const ParticleType &type_particle_a = scattering_particles_[0].type();
    const ParticleType &type_particle_b = scattering_particles_[1].type();

    const double m1 = scattering_particles_[0].effective_mass();
    const double m2 = scattering_particles_[1].effective_mass();
    const double p_cm_sqr = pCM_sqr(sqrt_s_, m1, m2);

    /* Find all the possible resonances */
    for (const ParticleType &type_resonance : ParticleType::list_all()) {
      /* Not a resonance, go to next type of particle */
      if (type_resonance.is_stable()) {
        continue;
      }

      /* Same resonance as in the beginning, ignore */
      if ((!type_particle_a.is_stable() &&
           type_resonance.pdgcode() == type_particle_a.pdgcode()) ||
          (!type_particle_b.is_stable() &&
           type_resonance.pdgcode() == type_particle_b.pdgcode())) {
        continue;
      }

      double resonance_xsection = formation(type_resonance, p_cm_sqr);

      /* If cross section is non-negligible, add resonance to the list */
      if (resonance_xsection > really_small) {
        resonance_process_list.push_back(make_unique<CollisionBranch>(
            type_resonance, resonance_xsection, ProcessType::TwoToOne));
        // log.debug("Found resonance: ", type_resonance);
        // log.debug("2->1 with original particles: ", type_particle_a,
        //           type_particle_b);
      }
    }
  }
  return resonance_process_list;
}

double cross_sections::formation(const ParticleType &type_resonance,
                                           double cm_momentum_sqr) {
  const ParticleType &type_particle_a = scattering_particles_[0].type();
  const ParticleType &type_particle_b = scattering_particles_[1].type();
  /* Check for charge conservation. */
  if (type_resonance.charge() !=
      type_particle_a.charge() + type_particle_b.charge()) {
    return 0.;
  }

  /* Check for baryon-number conservation. */
  if (type_resonance.baryon_number() !=
      type_particle_a.baryon_number() + type_particle_b.baryon_number()) {
    return 0.;
  }

  /* Calculate partial in-width. */
  const double partial_width = type_resonance.get_partial_in_width(
      sqrt_s_, scattering_particles_[0], scattering_particles_[1]);
  if (partial_width <= 0.) {
    return 0.;
  }

  /* Calculate spin factor */
  const double spinfactor =
      static_cast<double>(type_resonance.spin() + 1) /
      ((type_particle_a.spin() + 1) * (type_particle_b.spin() + 1));
  const int sym_factor =
      (type_particle_a.pdgcode() == type_particle_b.pdgcode()) ? 2 : 1;
  /** Calculate resonance production cross section
   * using the Breit-Wigner distribution as probability amplitude.
   * See Eq. (176) in \iref{Buss:2011mx}. */
  return spinfactor * sym_factor * 2. * M_PI * M_PI / cm_momentum_sqr *
         type_resonance.spectral_function(sqrt_s_) * partial_width * hbarc *
         hbarc / fm2_mb;
}


///////////// HELPER FUNCTIONS ///////////////////

// CollisionBranchList cross_sections::bar_bar_to_nuc_nuc(
//              const bool is_anti_particles) {
//   const ParticleType &type_a = scattering_particles_[0].type();
//   const ParticleType &type_b = scattering_particles_[1].type();
//   CollisionBranchList process_list;
//
//   const double s = mandelstam_s();
//   const double sqrts = sqrt_s();
//   /* CM momentum in final state */
//   double p_cm_final = std::sqrt(s - 4. * nucleon_mass * nucleon_mass) / 2.;
//
//   ParticleTypePtrList nuc_or_anti_nuc;
//   if (is_anti_particles) {
//     nuc_or_anti_nuc = ParticleType::list_anti_nucleons();
//   } else {
//     nuc_or_anti_nuc = ParticleType::list_nucleons();
//   }
//
//   /* Loop over all nucleon or anti-nucleon charge states. */
//   for (ParticleTypePtr nuc_a : nuc_or_anti_nuc) {
//     for (ParticleTypePtr nuc_b : nuc_or_anti_nuc) {
//       /* Check for charge conservation. */
//       if (type_a.charge() + type_b.charge() !=
//           nuc_a->charge() + nuc_b->charge()) {
//         continue;
//       }
//       // loop over total isospin
//       for (const int twoI : I_tot_range(*nuc_a, *nuc_b)) {
//         const double isospin_factor = isospin_clebsch_gordan_sqr_2to2(
//             type_a, type_b, *nuc_a, *nuc_b, twoI);
//         /* If Clebsch-Gordan coefficient is zero, don't bother with the rest */
//         if (std::abs(isospin_factor) < really_small) {
//           continue;
//         }
//
//         /* Calculate matrix element for inverse process. */
//         const double matrix_element =
//             nn_to_resonance_matrix_element(sqrts, type_a, type_b, twoI);
//         if (matrix_element <= 0.) {
//           continue;
//         }
//
//         /** Cross section for 2->2 resonance absorption, obtained via detailed
//          * balance from the inverse reaction.
//          * See eqs. (B.6), (B.9) and (181) in \iref{Buss:2011mx}.
//          * There are factors for spin, isospin and symmetry involved. */
//         const double spin_factor = (nuc_a->spin() + 1) * (nuc_b->spin() + 1);
//         const int sym_fac_in =
//             (type_a.iso_multiplet() == type_b.iso_multiplet()) ? 2 : 1;
//         const int sym_fac_out =
//             (nuc_a->iso_multiplet() == nuc_b->iso_multiplet()) ? 2 : 1;
//         const double xsection = isospin_factor * spin_factor * sym_fac_in /
//                                 sym_fac_out * p_cm_final * matrix_element /
//                                 (s * cm_momentum());
//
//         if (xsection > really_small) {
//           process_list.push_back(make_unique<CollisionBranch>(
//               *nuc_a, *nuc_b, xsection, ProcessType::TwoToTwo));
//           const auto &log = logger<LogArea::ScatterAction>();
//           log.debug("2->2 absorption with original particles: ", type_a,
//                     type_b);
//         }
//       }
//     }
//   }
//   return process_list;
// }
//
// double cross_sections::nn_to_resonance_matrix_element(
//     double sqrts, const ParticleType &type_a, const ParticleType &type_b,
//     const int twoI) {
//   const double m_a = type_a.mass();
//   const double m_b = type_b.mass();
//   const double msqr = 2. * (m_a * m_a + m_b * m_b);
//   /* If the c.m. energy is larger than the sum of the pole masses of the
//    * outgoing particles plus three times of the sum of the widths plus 3 GeV,
//    * the collision will be neglected.*/
//   const double w_a = type_a.width_at_pole();
//   const double w_b = type_b.width_at_pole();
//   const double uplmt = m_a + m_b + 3.0 * (w_a + w_b) + 3.0;
//   if (sqrts > uplmt) {
//     return 0.;
//   }
//   /** NN → NΔ: fit sqrt(s)-dependence to OBE model [\iref{Dmitriev:1986st}] */
//   if (((type_a.is_Delta() && type_b.is_nucleon()) ||
//        (type_b.is_Delta() && type_a.is_nucleon())) &&
//       (type_a.antiparticle_sign() == type_b.antiparticle_sign())) {
//     return 68. / std::pow(sqrts - 1.104, 1.951);
//     /** All other processes use a constant matrix element,
//      *  similar to \iref{Bass:1998ca}, equ. (3.35). */
//   } else if (((type_a.is_Nstar() && type_b.is_nucleon()) ||
//               (type_b.is_Nstar() && type_a.is_nucleon())) &&
//              type_a.antiparticle_sign() == type_b.antiparticle_sign()) {
//     // NN → NN*
//     if (twoI == 2) {
//       return 7. / msqr;
//     } else if (twoI == 0) {
//       const double parametrization = 14. / msqr;
//       /* pn → pnη cross section is known to be larger than the corresponding
//        * pp → ppη cross section by a factor of 6.5 [\iref{Calen:1998vh}].
//        * Since the eta is mainly produced by an intermediate N*(1535) we
//        * introduce an explicit isospin asymmetry for the production of N*(1535)
//        * produced in pn vs. pp similar to [\iref{Teis:1996kx}], eq. 29. */
//       if (type_a.is_Nstar1535() || type_b.is_Nstar1535()) {
//         return 6.5 * parametrization;
//       } else {
//         return parametrization;
//       }
//     }
//   } else if (((type_a.is_Deltastar() && type_b.is_nucleon()) ||
//               (type_b.is_Deltastar() && type_a.is_nucleon())) &&
//              type_a.antiparticle_sign() == type_b.antiparticle_sign()) {
//     // NN → NΔ*
//     return 15. / msqr;
//   } else if ((type_a.is_Delta() && type_b.is_Delta()) &&
//              (type_a.antiparticle_sign() == type_b.antiparticle_sign())) {
//     // NN → ΔΔ
//     if (twoI == 2) {
//       return 45. / msqr;
//     } else if (twoI == 0) {
//       return 120. / msqr;
//     }
//   } else if (((type_a.is_Nstar() && type_b.is_Delta()) ||
//               (type_b.is_Nstar() && type_a.is_Delta())) &&
//              type_a.antiparticle_sign() == type_b.antiparticle_sign()) {
//     // NN → ΔN*
//     return 7. / msqr;
//   } else if (((type_a.is_Deltastar() && type_b.is_Delta()) ||
//               (type_b.is_Deltastar() && type_a.is_Delta())) &&
//              type_a.antiparticle_sign() == type_b.antiparticle_sign()) {
//     // NN → ΔΔ*
//     if (twoI == 2) {
//       return 15. / msqr;
//     } else if (twoI == 0) {
//       return 25. / msqr;
//     }
//   }
//   // all cases not listed: zero!
//   return 0.;
// }



}  // namespace smash
